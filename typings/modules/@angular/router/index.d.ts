// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/directives/router_link.d.ts
declare module '~@angular/router/src/directives/router_link' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { LocationStrategy } from '@angular/common';
import { OnChanges } from '@angular/core';
import { Router } from '~@angular/router/src/router';
import { ActivatedRoute } from '~@angular/router/src/router_state';
import { UrlTree } from '~@angular/router/src/url_tree';
/**
 * The RouterLink directive lets you link to specific parts of your app.
 *
 * Consider the following route configuration:

 * ```
 * [{ path: 'user/:name', component: UserCmp }]
 * ```
 *
 * When linking to this `User` route, you can write:
 *
 * ```
 * <a [routerLink]="/user/bob">link to user component</a>
 * ```
 *
 * If you use dynamic values to generate the link, you can pass an array of path
 * segments, followed by the params for each segment.
 *
 * For instance `['/team', teamId, 'user', userName, {details: true}]`
 * means that we want to generate a link to `/team/11/user/bob;details=true`.
 * Multiple static segments can be merged into one (e.g., `['/team/11/user', userName, {details:
 true}]`).
 *
 * The first segment name can be prepended with `/`, `./`, or `../`:
 * * If the first segment begins with `/`, the router will look up the route from the root of the
 app.
 * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
 * instead look in the children of the current activated route.
 * * And if the first segment begins with `../`, the router will go up one level.
 *
 * You can set query params and fragment as follows:
 *
 * ```
 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">link to user
 component</a>
 * ```
 *
 * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
 *
 * @stable
 */
export class RouterLink {
    private router;
    private route;
    private locationStrategy;
    private commands;
    queryParams: {
        [k: string]: any;
    };
    fragment: string;
    urlTree: UrlTree;
    constructor(router: Router, route: ActivatedRoute, locationStrategy: LocationStrategy);
    routerLink: any[] | string;
    onClick(button: number, ctrlKey: boolean, metaKey: boolean): boolean;
}
/**
 * See {@link RouterLink} for more information.
 * @stable
 */
export class RouterLinkWithHref implements OnChanges {
    private router;
    private route;
    private locationStrategy;
    target: string;
    private commands;
    queryParams: {
        [k: string]: any;
    };
    fragment: string;
    href: string;
    urlTree: UrlTree;
    routerLink: any[] | string;
    ngOnChanges(changes: {}): any;
    onClick(button: number, ctrlKey: boolean, metaKey: boolean): boolean;
    private updateTargetUrlAndHref();
}
}
declare module '@angular/router/src/directives/router_link' {
export * from '~@angular/router/src/directives/router_link';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/directives/router_link_active.d.ts
declare module '~@angular/router/src/directives/router_link_active' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AfterContentInit, ElementRef, OnChanges, OnDestroy, QueryList, Renderer } from '@angular/core';
import { Router } from '~@angular/router/src/router';
import { RouterLink, RouterLinkWithHref } from '~@angular/router/src/directives/router_link';
/**
 * The RouterLinkActive directive lets you add a CSS class to an element when the link's route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a [routerLink]="/user/bob" routerLinkActive="active-link">Bob</a>
 * ```
 *
 * When the url is either '/user' or '/user/bob', the active-link class will
 * be added to the `a` tag. If the url changes, the class will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a [routerLink]="/user/bob" routerLinkActive="class1 class2">Bob</a>
 * <a [routerLink]="/user/bob" routerLinkActive="['class1', 'class2']">Bob</a>
 * ```
 *
 * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
 * only when the url matches the link exactly.
 *
 * ```
 * <a [routerLink]="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
 * true}">Bob</a>
 * ```
 *
 * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
 *   <a [routerLink]="/user/jim">Jim</a>
 *   <a [routerLink]="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either '/user/jim' or
 * '/user/bob'.
 *
 * @stable
 */
export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {
    private router;
    private element;
    private renderer;
    links: QueryList<RouterLink>;
    linksWithHrefs: QueryList<RouterLinkWithHref>;
    private classes;
    private subscription;
    private routerLinkActiveOptions;
    constructor(router: Router, element: ElementRef, renderer: Renderer);
    ngAfterContentInit(): void;
    routerLinkActive: string[] | string;
    ngOnChanges(changes: {}): any;
    ngOnDestroy(): any;
    private update();
    private reduceList(currentUrlTree, q);
}
}
declare module '@angular/router/src/directives/router_link_active' {
export * from '~@angular/router/src/directives/router_link_active';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/directives/router_outlet.d.ts
declare module '~@angular/router/src/directives/router_outlet' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ResolvedReflectiveProvider } from '@angular/core';
import { RouterOutletMap } from '~@angular/router/src/router_outlet_map';
import { ActivatedRoute } from '~@angular/router/src/router_state';
/**
 * A router outlet is a placeholder that Angular dynamically fills based on the application's route.
 *
 * ## Use
 *
 * ```
 * <router-outlet></router-outlet>
 * <router-outlet name="left"></router-outlet>
 * <router-outlet name="right"></router-outlet>
 * ```
 *
 * @stable
 */
export class RouterOutlet {
    private location;
    private componentFactoryResolver;
    private activated;
    private _activatedRoute;
    outletMap: RouterOutletMap;
    isActivated: boolean;
    component: Object;
    activatedRoute: ActivatedRoute;
    deactivate(): void;
    activate(activatedRoute: ActivatedRoute, providers: ResolvedReflectiveProvider[], outletMap: RouterOutletMap): void;
}
}
declare module '@angular/router/src/directives/router_outlet' {
export * from '~@angular/router/src/directives/router_outlet';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/common_router_providers.d.ts
declare module '~@angular/router/src/common_router_providers' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Location } from '@angular/common';
import { ApplicationRef, ComponentResolver, Injector, OpaqueToken } from '@angular/core';
import { RouterConfig } from '~@angular/router/src/config';
import { Router } from '~@angular/router/src/router';
import { RouterOutletMap } from '~@angular/router/src/router_outlet_map';
import { UrlSerializer } from '~@angular/router/src/url_tree';
export const ROUTER_CONFIG: OpaqueToken;
export const ROUTER_OPTIONS: OpaqueToken;
/**
 * @experimental
 */
export interface ExtraOptions {
    enableTracing?: boolean;
}
export function setupRouter(ref: ApplicationRef, resolver: ComponentResolver, urlSerializer: UrlSerializer, outletMap: RouterOutletMap, location: Location, injector: Injector, config: RouterConfig, opts: ExtraOptions): Router;
export function setupRouterInitializer(injector: Injector): () => any;
/**
 * An array of {@link Provider}s. To use the router, you must add this to your application.
 *
 * ### Example
 *
 * ```
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * class AppCmp {
 *   // ...
 * }
 *
 * const config = [
 *   {path: 'home', component: Home}
 * ];
 *
 * bootstrap(AppCmp, [provideRouter(config)]);
 * ```
 *
 * @stable
 */
export function provideRouter(_config: RouterConfig, _opts: ExtraOptions): any[];
}
declare module '@angular/router/src/common_router_providers' {
export * from '~@angular/router/src/common_router_providers';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/config.d.ts
declare module '~@angular/router/src/config' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '@angular/core';
/**
 * `RouterConfig` is an array of route configurations. Each one has the following properties:
 *
 * - *`path`* is a string that uses the route matcher DSL.
 * - `pathMatch` is a string that specifies the matching strategy.
 * - `component` is a component type.
 * - `redirectTo` is the url fragment which will replace the current matched segment.
 * - `outlet` is the name of the outlet the component should be placed into.
 * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See {@link
 * CanActivate} for more info.
 * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See {@link
 * CanDeactivate} for more info.
 * - `data` is additional data provided to the component via `ActivatedRoute`.
 * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more
 * info.
 * - `children` is an array of child route definitions.
 *
 * ### Simple Configuration
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [
 *     {
 *       path: 'user/:name',
 *       component: User
 *     }
 *   ]
 * }]
 * ```
 *
 * When navigating to `/team/11/user/bob`, the router will create the team component with the user
 * component in it.
 *
 * ### Multiple Outlets
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team
 * },
 * {
 *   path: 'chat/:user',
 *   component: Chat
 *   outlet: aux
 * }]
 * ```
 *
 * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to
 * the chat component. The chat component will be placed into the aux outlet.
 *
 * ### Wild Cards
 *
 * ```
 * [{
 *   path: '**',
 *   component: Sink
 * }]
 * ```
 *
 * Regardless of where you navigate to, the router will instantiate the sink component.
 *
 * ### Redirects
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [
 *     {
 *       path: 'legacy/user/:name',
 *       redirectTo: 'user/:name'
 *     },
 *     {
 *       path: 'user/:name',
 *       component: User
 *     }
 *   ]
 * }]
 * ```
 *
 * When navigating to '/team/11/legacy/user/jim', the router will change the url to
 * '/team/11/user/jim', and then will instantiate the team component with the user component
 * in it.
 *
 * If the `redirectTo` value starts with a '/', then it is a global redirect. E.g., if in the
 * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.
 *
 * ### Empty Path
 *
 * Empty-path route configurations can be used to instantiate components that do not "consume"
 * any url segments. Let's look at the following configuration:
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [
 *     {
 *       path: '',
 *       component: AllUsers
 *     },
 *     {
 *       path: 'user/:name',
 *       component: User
 *     }
 *   ]
 * }]
 * ```
 *
 * When navigating to `/team/11`, the router will instantiate the AllUsers component.
 *
 * Empty-path routes can have children.
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [
 *     {
 *       path: '',
 *       component: WrapperCmp,
 *       children: [
 *         {
 *           path: 'user/:name',
 *           component: User
 *         }
 *       ]
 *     }
 *   ]
 * }]
 * ```
 *
 * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with
 * the user component in it.
 *
 * ### Matching Strategy
 *
 * By default the router will look at what is left in the url, and check if it starts with
 * the specified path (e.g., `/team/11/user` starts with `team/:id`).
 *
 * We can change the matching strategy to make sure that the path covers the whole unconsumed url,
 * which is akin to `unconsumedUrl === path` or `$` regular expressions.
 *
 * This is particularly important when redirecting empty-path routes.
 *
 * ```
 * [{
 *   path: '',
 *   pathMatch: 'prefix', //default
 *   redirectTo: 'main'
 * },
 * {
 *   path: 'main',
 *   component: Main
 * }]
 * ```
 *
 * Since an empty path is a prefix of any url, even when navigating to '/main', the router will
 * still apply the redirect.
 *
 * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to
 * '/'.
 *
 * ```
 * [{
 *   path: '',
 *   pathMatch: 'full',
 *   redirectTo: 'main'
 * },
 * {
 *   path: 'main',
 *   component: Main
 * }]
 * ```
 *
 * ### Componentless Routes
 *
 * It is useful at times to have the ability to share parameters between sibling components.
 *
 * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both
 * of them require some id parameter.
 *
 * One way to do that would be to have a bogus parent component, so both the siblings can get the id
 * parameter from it. This is not ideal. Instead, you can use a componentless route.
 *
 * ```
 * [{
 *    path: 'parent/:id',
 *    children: [
 *      { path: 'a', component: MainChild },
 *      { path: 'b', component: AuxChild, outlet: 'aux' }
 *    ]
 * }]
 * ```
 *
 * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux
 * child components next to each other. In this example, the application component
 * has to have the primary and aux outlets defined.
 *
 * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into
 * the `params`, `data`, and `resolve` of the children.
 *
 * This is especially useful when child components are defined as follows:
 *
 * ```
 * [{
 *    path: 'parent/:id',
 *    children: [
 *      { path: '', component: MainChild },
 *      { path: '', component: AuxChild, outlet: 'aux' }
 *    ]
 * }]
 * ```
 *
 * With this configuration in place, navigating to '/parent/10' will create the main child and aux
 * components.
 *
 * @stable
 */
export type RouterConfig = Route[];
/**
 * See {@link RouterConfig} for more details.
 * @stable
 */
export type Data = {
    [name: string]: any;
};
/**
 * See {@link RouterConfig} for more details.
 * @stable
 */
export type ResolveData = {
    [name: string]: any;
};
/**
 * See {@link RouterConfig} for more details.
 * @stable
 */
export interface Route {
    path?: string;
    /**
     * @deprecated - use `pathMatch` instead
     */
    terminal?: boolean;
    pathMatch?: 'full' | 'prefix';
    component?: Type | string;
    redirectTo?: string;
    outlet?: string;
    canActivate?: any[];
    canDeactivate?: any[];
    data?: Data;
    resolve?: ResolveData;
    children?: Route[];
}
export function validateConfig(config: RouterConfig): void;
}
declare module '@angular/router/src/config' {
export * from '~@angular/router/src/config';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/interfaces.d.ts
declare module '~@angular/router/src/interfaces' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Observable } from 'rxjs/Observable';
import { ActivatedRouteSnapshot, RouterStateSnapshot } from '~@angular/router/src/router_state';
/**
 * An interface a class can implement to be a guard deciding if a route can be activated.
 *
 * ### Example
 *
 * ```
 * class CanActivateTeam implements CanActivate {
 *   constructor(private permissions: Permissions, private currentUser: UserToken) {}
 *
 *   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):Observable<boolean> {
 *     return this.permissions.canActivate(this.currentUser, this.route.params.id);
 *   }
 * }
 *
 * bootstrap(AppComponent, [
 *   CanActivateTeam,
 *
 *   provideRouter([{
 *     path: 'team/:id',
 *     component: Team,
 *     canActivate: [CanActivateTeam]
 *   }])
 * );
 * ```
 *
 * You can also provide a function with the same signature instead of the class:
 *
 * ```
 * bootstrap(AppComponent, [
 *   {provide: 'canActivateTeam', useValue: (route: ActivatedRouteSnapshot, state:
 * RouterStateSnapshot) => true},
 *   provideRouter([{
 *     path: 'team/:id',
 *     component: Team,
 *     canActivate: ['canActivateTeam']
 *   }])
 * );
 * ```
 *
 * @stable
 */
export interface CanActivate {
    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | boolean;
}
/**
 * An interface a class can implement to be a guard deciding if a route can be deactivated.
 *
 * ### Example
 *
 * ```
 * class CanDeactivateTeam implements CanDeactivate {
 *   constructor(private permissions: Permissions, private currentUser: UserToken) {}
 *
 *   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):Observable<boolean> {
 *     return this.permissions.canDeactivate(this.currentUser, this.route.params.id);
 *   }
 * }
 *
 * bootstrap(AppComponent, [
 *   CanDeactivateTeam,
 *
 *   provideRouter([{
 *     path: 'team/:id',
 *     component: Team,
 *     canDeactivate: [CanDeactivateTeam]
 *   }])
 * );
 * ```
 *
 * You can also provide a function with the same signature instead of the class:
 *
 * ```
 * bootstrap(AppComponent, [
 *   {provide: 'canDeactivateTeam', useValue: (route: ActivatedRouteSnapshot, state:
 * RouterStateSnapshot) => true},
 *   provideRouter([{
 *     path: 'team/:id',
 *     component: Team,
 *     canActivate: ['canDeactivateTeam']
 *   }])
 * );
 * ```
 *
 * @stable
 */
export interface CanDeactivate<T> {
    canDeactivate(component: T, route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | boolean;
}
/**
 * An interface a class can implement to be a data provider.
 *
 * ### Example
 *
 * ```
 * class TeamResolver implements Resolve {
 *   constructor(private backend: Backend) {}
 *
 *   resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):Observable<any> {
 *     return this.backend.fetchTeam(this.route.params.id);
 *   }
 * }
 *
 * bootstrap(AppComponent, [
 *   TeamResolver,
 *
 *   provideRouter([{
 *     path: 'team/:id',
 *     component: TeamCmp,
 *     resolve: {
 *       team: TeamResolver
 *     }
 *   }])
 * );
 * ```
 *
 * You can also provide a function with the same signature instead of the class.
 *
 * @experimental
 */
export interface Resolve<T> {
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<any> | any;
}
}
declare module '@angular/router/src/interfaces' {
export * from '~@angular/router/src/interfaces';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/router.d.ts
declare module '~@angular/router/src/router' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/mergeAll';
import 'rxjs/add/operator/reduce';
import 'rxjs/add/operator/every';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/forkJoin';
import { Location } from '@angular/common';
import { ComponentResolver, Injector, Type } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { RouterConfig } from '~@angular/router/src/config';
import { RouterOutletMap } from '~@angular/router/src/router_outlet_map';
import { ActivatedRoute, RouterState, RouterStateSnapshot } from '~@angular/router/src/router_state';
import { Params } from '~@angular/router/src/shared';
import { UrlSerializer, UrlTree } from '~@angular/router/src/url_tree';
export interface NavigationExtras {
    relativeTo?: ActivatedRoute;
    queryParams?: Params;
    fragment?: string;
}
/**
 * An event triggered when a navigation starts
 *
 * @stable
 */
export class NavigationStart {
    id: number;
    url: string;
    constructor(id: number, url: string);
    toString(): string;
}
/**
 * An event triggered when a navigation ends successfully
 *
 * @stable
 */
export class NavigationEnd {
    id: number;
    url: string;
    urlAfterRedirects: string;
    constructor(id: number, url: string, urlAfterRedirects: string);
    toString(): string;
}
/**
 * An event triggered when a navigation is canceled
 *
 * @stable
 */
export class NavigationCancel {
    id: number;
    url: string;
    constructor(id: number, url: string);
    toString(): string;
}
/**
 * An event triggered when a navigation fails due to unexpected error
 *
 * @stable
 */
export class NavigationError {
    id: number;
    url: string;
    error: any;
    constructor(id: number, url: string, error: any);
    toString(): string;
}
/**
 * An event triggered when routes are recognized
 *
 * @stable
 */
export class RoutesRecognized {
    id: number;
    url: string;
    urlAfterRedirects: string;
    state: RouterStateSnapshot;
    constructor(id: number, url: string, urlAfterRedirects: string, state: RouterStateSnapshot);
    toString(): string;
}
/**
 * @stable
 */
export type Event = NavigationStart | NavigationEnd | NavigationCancel | NavigationError;
/**
 * The `Router` is responsible for mapping URLs to components.
 *
 * See {@link RouterConfig) for more details and examples.
 *
 * @stable
 */
export class Router {
    private rootComponentType;
    private resolver;
    private urlSerializer;
    private outletMap;
    private location;
    private injector;
    private currentUrlTree;
    private currentRouterState;
    private locationSubscription;
    private routerEvents;
    private navigationId;
    private config;
    /**
     * Creates the router service.
     */
    constructor(rootComponentType: Type, resolver: ComponentResolver, urlSerializer: UrlSerializer, outletMap: RouterOutletMap, location: Location, injector: Injector, config: RouterConfig);
    /**
     * Returns the current route state.
     */
    routerState: RouterState;
    /**
     * Returns the current url.
     */
    url: string;
    /**
     * Returns an observable of route events
     */
    events: Observable<Event>;
    /**
     * Resets the configuration used for navigation and generating links.
     *
     * ### Usage
     *
     * ```
     * router.resetConfig([
     *  { path: 'team/:id', component: TeamCmp, children: [
     *    { path: 'simple', component: SimpleCmp },
     *    { path: 'user/:name', component: UserCmp }
     *  ] }
     * ]);
     * ```
     */
    resetConfig(config: RouterConfig): void;
    /**
     * Applies an array of commands to the current url tree and creates
     * a new url tree.
     *
     * When given an activate route, applies the given commands starting from the route.
     * When not given a route, applies the given command starting from the root.
     *
     * ### Usage
     *
     * ```
     * // create /team/33/user/11
     * router.createUrlTree(['/team', 33, 'user', 11]);
     *
     * // create /team/33;expand=true/user/11
     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
     *
     * // you can collapse static fragments like this
     * router.createUrlTree(['/team/33/user', userId]);
     *
     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
     *
     * // navigate to /team/33/user/11/details
     * router.createUrlTree(['details'], {relativeTo: route});
     *
     * // navigate to /team/33/user/22
     * router.createUrlTree(['../22'], {relativeTo: route});
     *
     * // navigate to /team/44/user/22
     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
     * ```
     */
    createUrlTree(commands: any[], {relativeTo, queryParams, fragment}?: NavigationExtras): UrlTree;
    /**
     * Navigate based on the provided url. This navigation is always absolute.
     *
     * Returns a promise that:
     * - is resolved with 'true' when navigation succeeds
     * - is resolved with 'false' when navigation fails
     * - is rejected when an error happens
     *
     * ### Usage
     *
     * ```
     * router.navigateByUrl("/team/33/user/11");
     * ```
     */
    navigateByUrl(url: string | UrlTree): Promise<boolean>;
    /**
     * Navigate based on the provided array of commands and a starting point.
     * If no starting route is provided, the navigation is absolute.
     *
     * Returns a promise that:
     * - is resolved with 'true' when navigation succeeds
     * - is resolved with 'false' when navigation fails
     * - is rejected when an error happens
     *
     * ### Usage
     *
     * ```
     * router.navigate(['team', 33, 'team', '11], {relativeTo: route});
     * ```
     */
    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;
    /**
     * Serializes a {@link UrlTree} into a string.
     */
    serializeUrl(url: UrlTree): string;
    /**
     * Parse a string into a {@link UrlTree}.
     */
    parseUrl(url: string): UrlTree;
    private scheduleNavigation(url, preventPushState);
    private setUpLocationChangeListener();
    private runNavigate(url, preventPushState, id);
}
}
declare module '@angular/router/src/router' {
export * from '~@angular/router/src/router';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/router_outlet_map.d.ts
declare module '~@angular/router/src/router_outlet_map' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { RouterOutlet } from '~@angular/router/src/directives/router_outlet';
/**
 * @stable
 */
export class RouterOutletMap {
    registerOutlet(name: string, outlet: RouterOutlet): void;
}
}
declare module '@angular/router/src/router_outlet_map' {
export * from '~@angular/router/src/router_outlet_map';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/router_providers.d.ts
declare module '~@angular/router/src/router_providers' {
import { ExtraOptions } from '~@angular/router/src/common_router_providers';
import { RouterConfig } from '~@angular/router/src/config';
/**
 * A list of {@link Provider}s. To use the router, you must add this to your application.
 *
 * ### Example
 *
 * ```
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * class AppCmp {
 *   // ...
 * }
 *
 * const router = [
 *   {path: 'home', component: Home}
 * ];
 *
 * bootstrap(AppCmp, [provideRouter(router, {enableTracing: true})]);
 * ```
 *
 * @experimental
 */
export function provideRouter(config: RouterConfig, opts?: ExtraOptions): any[];
}
declare module '@angular/router/src/router_providers' {
export * from '~@angular/router/src/router_providers';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/utils/tree.d.ts
declare module '~@angular/router/src/utils/tree' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export class Tree<T> {
    constructor(root: TreeNode<T>);
    root: T;
    parent(t: T): T;
    children(t: T): T[];
    firstChild(t: T): T;
    siblings(t: T): T[];
    pathFromRoot(t: T): T[];
    contains(tree: Tree<T>): boolean;
}
export class TreeNode<T> {
    value: T;
    children: TreeNode<T>[];
    constructor(value: T, children: TreeNode<T>[]);
    toString(): string;
}
}
declare module '@angular/router/src/utils/tree' {
export * from '~@angular/router/src/utils/tree';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/router_state.d.ts
declare module '~@angular/router/src/router_state' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Data } from '~@angular/router/src/config';
import { Params } from '~@angular/router/src/shared';
import { UrlPathWithParams, UrlTree } from '~@angular/router/src/url_tree';
import { Tree } from '~@angular/router/src/utils/tree';
/**
 * The state of the router.
 *
 * ### Usage
 *
 * ```
 * class MyComponent {
 *   constructor(router: Router) {
 *     const state = router.routerState;
 *     const id: Observable<string> = state.firstChild(state.root).params.map(p => p.id);
 *     const isDebug: Observable<string> = state.queryParams.map(q => q.debug);
 *   }
 * }
 * ```
 *
 * @stable
 */
export class RouterState extends Tree<ActivatedRoute> {
    queryParams: Observable<Params>;
    fragment: Observable<string>;
    snapshot: RouterStateSnapshot;
    toString(): string;
}
export function createEmptyState(urlTree: UrlTree, rootComponent: Type): RouterState;
/**
 * Contains the information about a component loaded in an outlet. The information is provided
 * through the params, urlSegments, and data observables.
 *
 * ### Usage
 *
 * ```
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: Observable<string> = route.params.map(p => p.id);
 *     const data = route.data.map(d => d.user); //includes `data` and `resolve`
 *   }
 * }
 * ```
 *
 * @stable
 */
export class ActivatedRoute {
    url: Observable<UrlPathWithParams[]>;
    params: Observable<Params>;
    data: Observable<Data>;
    outlet: string;
    component: Type | string;
    snapshot: ActivatedRouteSnapshot;
    toString(): string;
}
/**
 * Contains the information about a component loaded in an outlet at a particular moment in time.
 *
 * ### Usage
 *
 * ```
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: string = route.snapshot.params.id;
 *     const data = route.snapshot.data;
 *   }
 * }
 * ```
 *
 * @stable
 */
export class ActivatedRouteSnapshot {
    url: UrlPathWithParams[];
    params: Params;
    data: Data;
    outlet: string;
    component: Type | string;
    toString(): string;
}
/**
 * The state of the router at a particular moment in time.
 *
 * ### Usage
 *
 * ```
 * class MyComponent {
 *   constructor(router: Router) {
 *     const snapshot = router.routerState.snapshot;
 *   }
 * }
 * ```
 *
 * @stable
 */
export class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {
    url: string;
    queryParams: Params;
    fragment: string;
    toString(): string;
}
/**
 * The expectation is that the activate route is created with the right set of parameters.
 * So we push new values into the observables only when they are not the initial values.
 * And we detect that by checking if the snapshot field is set.
 */
export function advanceActivatedRoute(route: ActivatedRoute): void;
}
declare module '@angular/router/src/router_state' {
export * from '~@angular/router/src/router_state';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/shared.d.ts
declare module '~@angular/router/src/shared' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Name of the primary outlet.
 * @type {string}
 *
 * @experimental
 */
export const PRIMARY_OUTLET: string;
/**
 * A collection of parameters.
 *
 * @experimental
 */
export type Params = {
    [key: string]: any;
};
}
declare module '@angular/router/src/shared' {
export * from '~@angular/router/src/shared';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/src/url_tree.d.ts
declare module '~@angular/router/src/url_tree' {
export function createEmptyUrlTree(): UrlTree;
export function containsTree(container: UrlTree, containee: UrlTree, exact: boolean): boolean;
/**
 * A URL in the tree form.
 *
 * @stable
 */
export class UrlTree {
    root: UrlSegment;
    queryParams: {
        [key: string]: string;
    };
    fragment: string;
    toString(): string;
}
/**
 * @stable
 */
export class UrlSegment {
    pathsWithParams: UrlPathWithParams[];
    children: {
        [key: string]: UrlSegment;
    };
    parent: UrlSegment;
    constructor(pathsWithParams: UrlPathWithParams[], children: {
        [key: string]: UrlSegment;
    });
    /**
     * Return true if the segment has child segments
     */
    hasChildren(): boolean;
    /**
     * Returns the number of child sements.
     */
    numberOfChildren: number;
    toString(): string;
}
/**
 * @stable
 */
export class UrlPathWithParams {
    path: string;
    parameters: {
        [key: string]: string;
    };
    constructor(path: string, parameters: {
        [key: string]: string;
    });
    toString(): string;
}
export function equalPathsWithParams(a: UrlPathWithParams[], b: UrlPathWithParams[]): boolean;
export function equalPath(a: UrlPathWithParams[], b: UrlPathWithParams[]): boolean;
export function mapChildren(segment: UrlSegment, fn: (v: UrlSegment, k: string) => UrlSegment): {
    [name: string]: UrlSegment;
};
export function mapChildrenIntoArray<T>(segment: UrlSegment, fn: (v: UrlSegment, k: string) => T[]): T[];
/**
 * Defines a way to serialize/deserialize a url tree.
 *
 * @experimental
 */
export abstract class UrlSerializer {
    /**
     * Parse a url into a {@Link UrlTree}
     */
    abstract parse(url: string): UrlTree;
    /**
     * Converts a {@Link UrlTree} into a url
     */
    abstract serialize(tree: UrlTree): string;
}
/**
 * A default implementation of the serialization.
 *
 * @experimental
 */
export class DefaultUrlSerializer implements UrlSerializer {
    parse(url: string): UrlTree;
    serialize(tree: UrlTree): string;
}
export function serializePaths(segment: UrlSegment): string;
export function serializePath(path: UrlPathWithParams): string;
}
declare module '@angular/router/src/url_tree' {
export * from '~@angular/router/src/url_tree';
}

// Generated by typings
// Source: jspm_packages/npm/@angular/router@3.0.0-beta.2/index.d.ts
declare module '~@angular/router/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { RouterLink, RouterLinkWithHref } from '~@angular/router/src/directives/router_link';
import { RouterLinkActive } from '~@angular/router/src/directives/router_link_active';
import { RouterOutlet } from '~@angular/router/src/directives/router_outlet';
export { ExtraOptions } from '~@angular/router/src/common_router_providers';
export { Data, ResolveData, Route, RouterConfig } from '~@angular/router/src/config';
export { RouterLink, RouterLinkWithHref } from '~@angular/router/src/directives/router_link';
export { RouterLinkActive } from '~@angular/router/src/directives/router_link_active';
export { RouterOutlet } from '~@angular/router/src/directives/router_outlet';
export { CanActivate, CanDeactivate, Resolve } from '~@angular/router/src/interfaces';
export { Event, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, Router, RoutesRecognized } from '~@angular/router/src/router';
export { RouterOutletMap } from '~@angular/router/src/router_outlet_map';
export { provideRouter } from '~@angular/router/src/router_providers';
export { ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot } from '~@angular/router/src/router_state';
export { PRIMARY_OUTLET, Params } from '~@angular/router/src/shared';
export { DefaultUrlSerializer, UrlPathWithParams, UrlSerializer, UrlTree } from '~@angular/router/src/url_tree';
/**
 * @stable
 */
export const ROUTER_DIRECTIVES: (typeof RouterOutlet | typeof RouterLink | typeof RouterLinkWithHref | typeof RouterLinkActive)[];
}
declare module '@angular/router/index' {
export * from '~@angular/router/index';
}
declare module '@angular/router' {
export * from '~@angular/router/index';
}
